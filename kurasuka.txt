import os
import re
#from socket import send_fds
from typing import Self
import zipfile
import shutil
import win32com.client
import tkinter as tk
from tkinter import messagebox
from datetime import datetime, timedelta
import pytz
import pikepdf
import csv

class PpapProcessor:
     def __init__(self, save_folder):
        # フォルダパスの設定
        self.save_folder = save_folder
        self.pdf_unlocked_folder = os.path.join(save_folder, "解除済")
        self.zip_extracted_folder = os.path.join(save_folder, "解凍済")
        self.normal_folder = os.path.join(save_folder, "ノーマル")
        self.mail_body_folder = os.path.join(save_folder, "メール本文")
        self.gattai_folder = os.path.join(save_folder, "00_合体フォルダ")

        # フォルダの存在チェックと作成
        os.makedirs(self.save_folder, exist_ok=True)
        os.makedirs(self.pdf_unlocked_folder, exist_ok=True)
        os.makedirs(self.zip_extracted_folder, exist_ok=True)
        os.makedirs(self.normal_folder, exist_ok=True)
        os.makedirs(self.mail_body_folder, exist_ok=True)
        os.makedirs(self.gattai_folder, exist_ok=True)

        # 処理結果リストの初期化
        self.successful_operations = []
        self.failed_unlocks = []
        self.failed_extractions = []
        self.scripted_pdfs = []
        self.filter_str = ""
        self.virtual_area_2 = []
        self.failed_unlocks=[]

        # 日付入力フォーム用の変数
        self.root = None
        self.entry_start = None
        self.entry_end = None
        self.date_from = None
        self.date_to = None
        #その他初期化
        self.read_pointer = 0  # ← virtual_area_2のSTART-POINT 相当
    #======================================================================================#
    #  処理基幹部
    #======================================================================================#
     def run(self):
        """
        メインの処理フローを実行するメソッド
        """
        self._get_dates_from_form()
        self._process_emails()
        #=========================================
        while True:
            msg_data = self.tenpufaile_get()

            if msg_data is None:
                break  # WK-EOF = 1 相当
            elif len(msg_data["attachments"]) ==0 :
              self.tenpufaile_nashi()
            else:                
                for attachment in msg_data["attachments"]:
                    self.tenpufaile_ari(attachment)
        #=========================================
        self._create_summary_csv()
        self._create_gattai_folder()
    #======================================================================================#
    #  対象日付を入力
    #======================================================================================#
     def _get_dates_from_form(self):
        """
        Tkinterを使って抽出期間を入力するフォームを表示する。
        """
        def submit():
            try:
                start = datetime.strptime(self.entry_start.get(), "%Y%m%d")
                end = datetime.strptime(self.entry_end.get(), "%Y%m%d") + timedelta(days=1) - timedelta(seconds=1)
                
                self.date_from = start
                self.date_to = end
                start_str = self.date_from.strftime('%m/%d/%Y %H:%M %p')
                end_str = self.date_to.strftime('%m/%d/%Y %H:%M %p')
                self.filter_str = f"[ReceivedTime] >= '{start_str}' AND [ReceivedTime] <= '{end_str}'"
                
                self.root.destroy()
            except ValueError:
                messagebox.showerror("入力エラー", "日付は YYYYMMDD 形式で入力してください。")

        self.root = tk.Tk()
        self.root.title("抽出期間の入力")
        self.root.geometry("400x250")
        font_large = ("Meiryo", 14)

        tk.Label(self.root, text="開始日（YYYYMMDD）", font=font_large).pack(pady=10)
        self.entry_start = tk.Entry(self.root, font=font_large, width=20)
        self.entry_start.pack()

        tk.Label(self.root, text="終了日（YYYYMMDD）", font=font_large).pack(pady=10)
        self.entry_end = tk.Entry(self.root, font=font_large, width=20)
        self.entry_end.pack()

        tk.Button(self.root, text="実行", font=font_large, command=submit).pack(pady=20)
        self.root.mainloop()
    #======================================================================================#
    #  処理対象のメールを抽出
    #======================================================================================#
     def _process_emails(self):
        """
        メールを処理するメインのループ
        """
        outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
        inbox = outlook.GetDefaultFolder(6)
        messages = inbox.Items.Restrict(self.filter_str)
        messages.Sort("[ReceivedTime]", False)
        self.virtual_area_2 = []

        for message in messages:
            try:
                if message.Class == 43:
                    subject = message.Subject or ""
                    if any(keyword in subject for keyword in ["請求書", "パスワード", "開封パスワード", "暗号", "Password", "PW"]):
                        self.male_naiyo_get(message, subject)
            except Exception as e:
                print(f"仮想領域2抽出エラー: {e}")
    #======================================================================================#
    #  対象メールの辞書化
    #======================================================================================#
     def male_naiyo_get(self, message, subject):
            snd_Email_Addr = message.SenderEmailAddress

            self.virtual_area_2.append({
                "message": message,
                #"sender": message.SenderEmailAddress,
                "sender": snd_Email_Addr,
                "subject": subject,
                "body": message.Body or "",
                "received": message.ReceivedTime,
                "attachments": message.Attachments
            })                  
    #======================================================================================#
    #  対象メールの辞書化→1件単位抽出
    #======================================================================================#
     def tenpufaile_get(self):
       if self.read_pointer >= len(self.virtual_area_2):
           return None  # EOF 相当
       else:
           msg_data = self.virtual_area_2[self.read_pointer]
           self.read_pointer += 1  # 次の位置へ進める

           self.sender = msg_data["sender"]
           self.received = msg_data["received"]
           self.message = msg_data["message"]
           self.body = msg_data["body"]
           self.subject = msg_data["subject"]

           # 添付ファイルの処理
           self.attachments = msg_data.get("attachments", [])   # "attachments"が有無を判定しあれば設定、無ければNULL
           self.attachment_items = []  # 添付ファイルを格納するリスト
           for attachment in self.attachments:
               self.attachment_items.append(attachment)

           return msg_data  
    #======================================================================================#
    #  添付ファイルなしの請求書メール
    #======================================================================================#
     def tenpufaile_nashi(self):
            body = self.body
            subject = self.subject
            safe_subject = re.sub(r'[\\/:*?"<>|\t\n\r]', '', subject)
            body_filename = f"本文_{safe_subject}.txt"
            body_path = os.path.join(self.mail_body_folder, body_filename)
            urls = re.findall(r'https?://[a-zA-Z0-9\.\-/_%&?=#]+', body)
            url_text = "\n\n--- 抽出されたURL ---\n" + "\n".join(urls) if urls else ""
            with open(body_path, "w", encoding="utf-8") as f:
                f.write(body + url_text)
            print(f"添付ファイルなし → 本文を保存: {body_path}")
            self.successful_operations.append({"種別": "本文保存", "filename": body_filename, "received": self.received, "urls": urls})
    #======================================================================================#
    #  添付ファイルありの請求書メール
    #======================================================================================#     
     def tenpufaile_ari(self, attachment):
            self.filename = attachment.filename.lower()
            self.file_path = os.path.join(self.save_folder, self.filename)
            attachment.SaveAsFile(self.file_path)
				
            if self.filename.endswith(".pdf"):
                try:
                        with pikepdf.open(self.file_path) as pdf:
                         self.pdf_shori_proc(attachment)       
                except pikepdf.PasswordError:
                        self.pdf_psw_ari_shori_proc(attachment)
                except Exception as e:
                        print(f"PDF処理エラー: {self.filename} → {e}")

            elif self.filename.endswith(".zip"):
                password = self._find_best_password(self.sender, self.received)
                if password:
                    if self._extract_zip_with_encoding(self.file_path, password, self.received):
                        self.successful_operations.append({"種別": "ZIP解凍成功", "filename": self.filename, "received": self.received})
                    else:
                        self.failed_extractions.append({"filename": self.filename, "received": self.received})
                else:
                    try:
                        self.kaitos_seiko_shori_proc(attachment)
                    except Exception as e:
                        self.sonota_shori_proc(attachment)
    #======================================================================================#
    #  添付ファイルの請求書がＺＩＰの場合＿ＰＰＡＰ等パスワードが書いてあるメールを特定
    #======================================================================================#
     def _find_best_password(self, sender, received_time):
        """
        送信者と受信日時が最も近いメールからパスワードを検索する。
        """
        best_msg = None
        min_diff = float('inf')
        
        #---<パスワード抽出(本体メールは対象外)
        for msg_data in self.virtual_area_2:
            if msg_data["sender"] != sender:
               continue
                
            body = msg_data["body"]
            received = msg_data["received"]
            if received_time ==  received:
               continue
            if "パスワード" in body or "開封パスワード" in body:
                diff = abs((received_time - received).total_seconds())
                if diff < min_diff:
                    min_diff = diff
                    best_msg = msg_data
                    
        #---<パスワード抽出
        return self._extract_password(best_msg["body"]) if best_msg else None
    #======================================================================================#
    #  添付ファイルの請求書がＺＩＰの場合＿最善のパスワードを取得
    #======================================================================================#    
     def _extract_password(self, body):
        """
        メール本文からパスワードらしき文字列を抽出する。
        """
        keywords = ["パスワード", "開封パスワード", "暗号", "Password", "PW"]
        lines = body.splitlines()
        
   　#--<同一行のパスワード記述>
        for i, line in enumerate(lines):
            if any(keyword in line for keyword in keywords):
               candidate = lines[i].strip()
               for keyword in keywords:
                   match = re.search(fr"{keyword}[^A-Za-z0-9\-]*([A-Za-z0-9\-]{6,}))", candidate)
                   if match:
                      return match.group(1)

     #--<同一行以外のパスワード記述>
        for i, line in enumerate(lines):
            if any(keyword in line for keyword in keywords):
                for j in range(max(0, i - 5), min(len(lines), i + 6)):
                    candidate = lines[j].strip()
                    for keyword in keywords:
                        match = re.search(fr"{keyword}[^A-Za-z0-9\-]*([A-Za-z0-9\-]{6,})", candidate)
                        if match:
                           return match.group(1)
     #---<パスワードが取得できない時
        return None


    #======================================================================================#
    #  添付ファイルの請求書がＰＤＦの場合
    #======================================================================================#     
     def pdf_shori_proc(self,attachment):

        if '/AcroForm' in self.pdf.root and '/JavaScript' in self.pdf.root.AcroForm:
            print(f"PDFにスクリプトが含まれています: {attachment.filename}")
            self.scripted_pdfs.append({"filename": attachment.filename, "received": self.received})
        else:
            normal_path = os.path.join(self.normal_folder, attachment.filename)
        if not os.path.exists(normal_path):
            self.pdf.save(normal_path)
            print(f"PDFノーマル保存: {normal_path}")
            self.successful_operations.append({"種別": "PDFノーマル保存", "filename": attachment.filename, "received": self.received})
        else:
            print(f"PDFノーマル保存スキップ: {normal_path} はすでに存在します。")
    #======================================================================================#
    #  添付ファイルの請求書がＺＩＰの場合＿ＺＩＰ処理主処理
    #======================================================================================#    
     def pdf_psw_ari_shori_proc(self,attachment):
        password = self._find_best_password(self.sender, self.received)
        
        if password:
            try:
                self.kagi_proc()
            except Exception as e:
                   print(f"PDF解除失敗: {attachment.filename} → {e}")
                   self.failed_unlocks.append({"filename": attachment.filename, "received": self.received})
        else:
            print(f"PDFパスワード不明: {attachment.filename}")
            self.failed_unlocks.append({"filename": attachment.filename, "received": self.received})

    #======================================================================================#
    #  添付ファイルの請求書がＺＩＰの場合＿鍵解除処理
    #======================================================================================#    
     def kagi_proc(self,attachment):
        with pikepdf.open(self.file_path, password=self.password) as pdf:
            if '/AcroForm' in pdf.root and '/JavaScript' in pdf.root.AcroForm:
                print(f"PDFにスクリプトが含まれています: {attachment.filename}")
                self.scripted_pdfs.append({"filename": attachment.filename, "received": received})
            else:
                unlocked_path = os.path.join(self.pdf_unlocked_folder, "unlocked_" + attachment.FileName)
                if not os.path.exists(unlocked_path):
                    pdf.save(unlocked_path)
                    print(f"PDF解除成功: {unlocked_path}")
                    self.successful_operations.append({"種別": "PDF解除成功", "filename": attachment.filename, "received": self.received})
                else:
                    print(f"PDF解除保存スキップ: {unlocked_path} はすでに存在します。")
                    
    #======================================================================================#
    #  添付ファイルの請求書がＺＩＰの場合＿解凍処理
    #======================================================================================#    ##
     def _extract_zip_with_encoding(self, zip_path, password, received):
        """
        パスワード付きZIPファイルを解凍し、中身を保存する。
        """
        try:
            with zipfile.ZipFile(zip_path) as zf:
                for info in zf.infolist():
                    if info.is_dir():
                        continue  # ディレクトリはスキップ
                    try:
                        filename = self._decode_filename(info.filename)
                    except:
                        filename = info.filename
                    
                    # パスからファイル名のみを抽出して保存
                    target_path = os.path.join(self.zip_extracted_folder, os.path.basename(filename))
                    
                    # ファイルがすでに存在する場合はスキップ
                    if not os.path.exists(target_path):  #←パスワードより解凍する
                        with zf.open(info, pwd=bytes(password, 'utf-8')) as source, open(target_path, 'wb') as target:
                            shutil.copyfileobj(source, target)
                    else:
                        print(f"ZIP解凍済みのためスキップ: {target_path} はすでに存在します。")
            print(f"ZIP解凍成功: {zip_path}")
            return True
        except Exception as e:
            print(f"ZIP解凍失敗: {zip_path} → {e}")
            return False

    #======================================================================================#
    #  ＺＩＰ文字化けを修正
    #======================================================================================#    ##
     def _decode_filename(self, raw_name):
        """
        ZIPファイル内の文字化けしたファイル名を正しくデコードする。
        """
        for encoding in ['utf-8', 'shift_jis', 'cp932']:
            try:
                decoded_name = raw_name.encode('cp437').decode(encoding)
                # Windowsで許可されていない文字を削除
                return re.sub(r'[\\/:*?"<>|]', '', decoded_name)
            except:
                continue
        return raw_name


    ########################################################################################
     def kaitos_seiko_shori_proc(self,attachment):
        if self._extract_zip_with_encoding(self.file_path, "akkodis2025", self.received):
            self.successful_operations.append({"種別": "ZIP解凍成功", "filename": attachment.filename, "received": self.received})
        else:
            ntfnd_filename = "NTFND_" + self.attachment.filename
            ntfnd_path = os.path.join(self.normal_folder, ntfnd_filename)
            if not os.path.exists(ntfnd_path):
                shutil.move(self.file_path, ntfnd_path)
                print(f"ZIPパスワード不明 → ノーマル保存: {ntfnd_path}")
                self.failed_extractions.append({"filename": ntfnd_filename, "received": self.received})
            else:
                print(f"ZIPパスワード不明 → ノーマル保存スキップ: {ntfnd_path} はすでに存在します。")
                
                
     def sonota_shori_proc(self,attachment):
        ntfnd_filename = "NTFND_" +  attachment.filename
        ntfnd_path = os.path.join(self.normal_folder, ntfnd_filename)

        if not os.path.exists(ntfnd_path):
            shutil.move(self.file_path,ntfnd_path)
            print(f"ZIPパスワード不明 → ノーマル保存: {ntfnd_path}")
            self.failed_extractions.append({"filename": ntfnd_filename, "received": self.received})
        else:
            print(f"ZIPパスワード不明 → ノーマル保存スキップ: {ntfnd_path} はすでに存在します。")
    
    
    ########################################################################################
     def _create_summary_csv(self):
        """
        処理結果をCSVファイルに保存する。
        """
        summary_csv_path = os.path.join(self.save_folder, "処理結果_summary.csv")
        with open(summary_csv_path, mode='w', newline='', encoding='utf-8-sig') as file:
            writer = csv.writer(file)
            writer.writerow(["種別", "ファイル名", "受信日時（日本時間）", "URL"])
            
            for item in self.successful_operations:
                urls = ",".join(item.get("urls", []))
                writer.writerow([item["種別"], item["filename"], item["received"].strftime("%Y/%m/%d %H:%M"), urls])
            
            for item in self.failed_unlocks:
                writer.writerow(["★★解除失敗（PDF）★★", item["filename"], item["received"].strftime("%Y/%m/%d %H:%M"), ""])
            for item in self.failed_extractions:
                writer.writerow(["★★解凍失敗（ZIP）★★", item["filename"], item["received"].strftime("%Y/%m/%d %H:%M"), ""])
            for item in self.scripted_pdfs:
                writer.writerow(["★★スクリプト付きPDF★★", item["filename"], item["received"].strftime("%Y/%m/%d %H:%M"), ""])

        print("処理結果をCSVファイルに保存しました: {}".format(summary_csv_path))
    ########################################################################################
     def _create_gattai_folder(self):
        """
        指定されたフォルダにあるすべてのPDFファイルを合体フォルダにコピーする。
        """
        folders_to_copy = [self.pdf_unlocked_folder, self.normal_folder, self.zip_extracted_folder]
        
        for folder in folders_to_copy:
            for filename in os.listdir(folder):
                if filename.lower().endswith('.pdf'):
                    source_path = os.path.join(folder, filename)
                    dest_path = os.path.join(self.gattai_folder, filename)
                    if not os.path.exists(dest_path):
                        shutil.copy2(source_path, dest_path)
                        print(f"コピー: {source_path} -> {dest_path}")
                    else:
                        print(f"スキップ: {dest_path} はすでに存在します。")

# --- メイン処理の開始 ---
if __name__ == '__main__':
   processor = PpapProcessor(save_folder=r"C:\Users\016215\Desktop\ai_ocr\メール")
   processor.run()

